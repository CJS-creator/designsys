import { DesignToken } from "@/types/tokens";

/**
 * Advanced SwiftUI Exporter
 * Supports semantic tokens, aliasing, and multiple theme modes.
 */
export function exportToSwiftUIPro(tokens: DesignToken[], dsName: string): string {
    const colorTokens = tokens.filter(t => t.type === 'color');
    const spacingTokens = tokens.filter(t => t.type === 'spacing' || t.path.includes('spacing'));
    const radiusTokens = tokens.filter(t => t.type === 'borderRadius' || t.path.includes('radius'));
    const typographyTokens = tokens.filter(t => t.type === 'typography');

    const parseToSwiftColor = (hex: string) => {
        if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) return 'Color.clear';
        const r = parseInt(hex.substring(1, 3), 16) / 255;
        const g = parseInt(hex.substring(3, 5), 16) / 255;
        const b = parseInt(hex.substring(5, 7), 16) / 255;
        return `Color(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)})`;
    };

    const normalizeKey = (path: string) => {
        return path.replace(/[.-]/g, '_').toLowerCase();
    };

    return `import SwiftUI

/**
 * DesignTokens.swift
 * Generated by DesignForge for ${dsName}
 */
public enum DesignTokens {
    public enum Colors {
        ${colorTokens.map(t => {
        const key = normalizeKey(t.path);
        const value = t.ref ? `// Alias: ${t.ref}` : parseToSwiftColor(t.value as string);
        return `/// ${t.description || t.name}\n        public static let ${key} = ${t.ref ? normalizeKey(t.ref.replace(/[{}]/g, '')) : value}`;
    }).join('\n\n        ')}
    }

    public enum Spacing {
        ${spacingTokens.map(t => {
        const key = normalizeKey(t.path);
        const val = parseFloat(String(t.value)) || 0;
        return `public static let ${key}: CGFloat = ${val}`;
    }).join('\n        ')}
    }

    public enum Radius {
        ${radiusTokens.map(t => {
        const key = normalizeKey(t.path);
        const val = parseFloat(String(t.value)) || 0;
        return `public static let ${key}: CGFloat = ${val}`;
    }).join('\n        ')}
    }

    public struct Typography {
        ${typographyTokens.map(t => {
        const key = normalizeKey(t.path);
        const val = t.value as any;
        return `public static let ${key} = Font.custom("${val.fontFamily}", size: ${parseFloat(val.fontSize)})`;
    }).join('\n        ')}
    }
}

// Helper for Color Aliases if needed
extension Color {
    static let design = DesignTokens.Colors.self
}
`;
}
